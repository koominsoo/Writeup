checksec
ls
ls
pdisas main
b *main+185
r
7ffff7dd0760
n
n
n
n
n
n
n
n
x/x $rbp+r
x/x $rbp+4
x/4x $rbp+4
r
n
x/x $rbp+4
r
x/4x $rbp+4
pdisas 0x5555
x/i 0x5555
pdisas main
b *main+23
r
x/4x $rbp+4
x/x $rbp+4
pdisas $rbp+4
x/50i 0xf7a05b9700005555
x/50i *$rbp+4
x/50i *($rbp+4)
info func
pdisas main
checksec
m,mp
mmap
map
start
ps
readekg
readelf
pdias 0x555555554c14
pdisas 0x555555554c14
pdisas _fini
pdisas fini
p free
strat
start
p stdout
p get_shell
pdisas 0x5636be03ab80
print $rdx
x/4x $rdx
pdisas main
x/x $rdx
x/2x $rdx
x/4x $rdx
readelf
start
readelf
pdisas init
ps
pdisas fini_array
pdisas fini_array
pdisas fini
pdisas free
readelf
pdisas fini
pdisas free
pdisas fini
vmmap
start
vmmap
p _rtld_global
pdisas main
x/4x $rdx
pdisas $rdx
start
x/x _rtld_global
p _rtld_global
p _dl_fini
vmmap
fini.py에서 주목해야 하는 부분은 line 18~19입니다. 프로그램은 한 번 임의 주소 쓰기를 실행한 후 exit 함수를 호출해 종료하기 때문에, _rtld_lock_lock_recursive 함수 포인터와 _dl_load_lock 인자를 동시에 조작할 수 없습니다. 따라서 _rtld_lofini.py에서 주목해야 하는 부분은 line 18~19입니다. 프로그램은 한 번 임의 주소 쓰기를 실행한 후 exit 함수를 호출해 종료하기 때문에, _rtld_lock_lock_recursive 함수 포인터와 _dl_load_lock 인자를 동시에 조작할 수 없습니다. 따라서 _rtld_lo
p _rtld_recursive
p _rtld_global+3840
x/x &_rtld_global
x/x &_rtld_global+3840
x/x &_rtld_global+10
x/x _rtld_global
x/x 0x7ffff7ffe170
pdisas 0x7ffff7ffe170
x/10x 0x7ffff7ffe170
x/x 0x555555554000
pdisas 0x555555554000
pdisas 0x555555554047
print $rdx
pdisas $rdx
checksec
info func
start
pdisas __libc_start_main
x/x $rbp+4
x/x $rbp+8
pdisas __GI_exit
pdisas __run_exit_handlers
pdisas __GI__exit
